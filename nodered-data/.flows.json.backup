[
    {
        "id": "f6f2187d.f17ca8",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": ""
    },
    {
        "id": "bad1a1ab4cc09f88",
        "type": "Kafka Broker",
        "name": "local kafka",
        "hosts": [
            {
                "host": "kafka",
                "port": 9093
            }
        ],
        "hostsEnvVar": "",
        "connectTimeout": "100",
        "requestTimeout": "36000",
        "autoConnect": "true",
        "idleConnection": "5",
        "reconnectOnIdle": "true",
        "maxAsyncRequests": "10",
        "checkInterval": "10",
        "selfSign": true,
        "usetls": false,
        "useCredentials": false
    },
    {
        "id": "f4640e98347ece66",
        "type": "mqtt-broker",
        "name": "smt1-printer",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/printer/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/printer/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/printer/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "f2e4c66763f10fa9",
        "type": "mqtt-broker",
        "name": "smt1-loader",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/loader/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/loader/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/loader/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "43a8f184b06a8296",
        "type": "mqtt-broker",
        "name": "smt1-spi",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/spi/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/spi/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/spi/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "be3e1f50d2e272ac",
        "type": "mqtt-broker",
        "name": "smt1-pp1",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/pp1/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/pp1/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/pp1/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "ee0822dd8f04d988",
        "type": "mqtt-broker",
        "name": "smt1-pp2",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/pp2/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/pp2/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/pp2/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "d4e5ec3427485135",
        "type": "mqtt-broker",
        "name": "smt1-aoi1",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/aoi1/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/aoi1/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/aoi1/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "4c30baa4e5ca2436",
        "type": "mqtt-broker",
        "name": "smt1-oven",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/oven/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/oven/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/oven/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "27fc9fe771719233",
        "type": "mqtt-broker",
        "name": "smt1-aoi2",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "smt1/aoi2/status",
        "birthQos": "0",
        "birthRetain": "true",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "smt1/aoi2/status",
        "closeQos": "0",
        "closeRetain": "true",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "smt1/aoi2/status",
        "willQos": "0",
        "willRetain": "true",
        "willPayload": "disconnected",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "5afc3e3855fc7545",
        "type": "postgreSQLConfig",
        "name": "smt",
        "host": "smt-postgres",
        "hostFieldType": "str",
        "port": 5432,
        "portFieldType": "num",
        "database": "smt",
        "databaseFieldType": "str",
        "ssl": "false",
        "sslFieldType": "bool",
        "applicationName": "",
        "applicationNameType": "str",
        "max": 10,
        "maxFieldType": "num",
        "idle": 1000,
        "idleFieldType": "num",
        "connectionTimeout": 10000,
        "connectionTimeoutFieldType": "num",
        "user": "smtadmin",
        "userFieldType": "str",
        "password": "110113",
        "passwordFieldType": "str"
    },
    {
        "id": "17b326f813964c67",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "LOADER",
        "func": "// ============================================\n// STATION 1: LOADER (Station Number: 1001)\n// Back-to-back loading: next entry = previous Loader exit\n// First run seeds from DB max(date_created) if available\n// ============================================\n\n// 1) Read saved Loader exit time (persisted across messages)\nlet lastLoaderExitTime = flow.get('lastLoaderExitTime');\n\n// 2) If we don't have a saved Loader exit yet, try DB seed\n//    Upstream Postgres node should set: msg.payload[0].last_timestamp\nlet lastDBTimestamp = msg.payload?.[0]?.last_timestamp;\n\n// 3) Decide entry time: prefer saved Loader exit; else DB; else now\nconst entryTime = lastLoaderExitTime\n  ? lastLoaderExitTime\n  : (lastDBTimestamp ? new Date(lastDBTimestamp).getTime() : Date.now());\n\n// 4) Usual counters / IDs\nlet pcbCounter = flow.get('pcbCounter') || 0;\npcbCounter++;\nflow.set('pcbCounter', pcbCounter);\n\nconst serialNumber = \"PCB\" + Date.now().toString().padStart(13, '0');\nconst batchNumber = Math.floor(pcbCounter / 800);\nconst partNumber = \"PN-\" + String(batchNumber).padStart(6, '0');\n\n// 5) Simulate Loader cycle (3–5 s)\nconst stayTimeMs = (3 + Math.random() * 2) * 1000; // ms\nconst exitTime = entryTime + stayTimeMs;\nconst cycleTime = (stayTimeMs / 1000).toFixed(2);\n\n// 6) Remember this Loader exit for the *next* PCB\nflow.set('lastLoaderExitTime', exitTime);\n\n// 7) Record\nconst bookingId = \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\nmsg.payload = {\n  station_record: {\n    BOOKING_ID: bookingId,\n    SERIAL_NUMBER: serialNumber,\n    STATION_NUMBER: \"1001\",\n    BOOK_STATE: \"PASS\",\n    // For Loader we log the station event at its *exit* time\n    DATE_CREATED: new Date(exitTime).toString(),\n    PART_NUMBER: partNumber,\n    CYCLE_TIME: parseFloat(cycleTime),\n    TEST_COUNT: 1\n  },\n  pcb_tracking: {\n    SERIAL_NUMBER: serialNumber,\n    PART_NUMBER: partNumber,\n    // Downstream stations should start from Loader's *exit* moment\n    entry_time: exitTime,\n    test_count: { loader: 1 }\n  }\n};\n\n// Debug (optional)\nif (!lastLoaderExitTime && lastDBTimestamp) {\n  node.warn(`Seeded Loader start from DB max(date_created): ${lastDBTimestamp}`);\n} else if (!lastLoaderExitTime && !lastDBTimestamp) {\n  node.warn(\"No DB seed found — starting Loader from 'now'.\");\n}\nnode.warn(`Loader: entry=${new Date(entryTime).toISOString()} exit=${new Date(exitTime).toISOString()}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 180,
        "wires": [
            [
                "0c26ab5f5ce5ca69",
                "53ff54009992a544"
            ]
        ]
    },
    {
        "id": "c72a4935dbd7b1a0",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "SPI",
        "func": "// STATION 3: SPI (Station Number: 1003)\n// ============================================\n\nlet pcb = msg.payload.pcb_tracking;\n\n// Calculate timing\nconst entryTime = pcb.entry_time;\nconst stayTime = (4 + Math.random() * 2) * 1000; // 4–6 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// SPI inspection – 20–25% fail rate\n// Randomly pick a fail rate between 0.20 and 0.25 for realism\nconst failRate = 0.05 + Math.random() * 0.03;\nconst failChance = Math.random();\nconst bookState = failChance < failRate ? \"FAIL\" : \"PASS\";\n\n// Generate unique BOOKING_ID\nconst bookingId = \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// Build message payload\nmsg.payload = {\n    station_record: {\n        BOOKING_ID: bookingId,\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        STATION_NUMBER: \"1003\",\n        BOOK_STATE: bookState,\n        DATE_CREATED: new Date(exitTime).toISOString(),\n        PART_NUMBER: pcb.PART_NUMBER,\n        CYCLE_TIME: cycleTime,\n        TEST_COUNT: 1   // ✅ Always 1 (no retests for SPI)\n    },\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        PART_NUMBER: pcb.PART_NUMBER,\n        entry_time: exitTime,\n        test_count: pcb.test_count\n    }\n};\n\n// Output logic\n// PASS → continue to next station\n// FAIL → stop (goes to second output)\nif (bookState === \"FAIL\") {\n    return [null, msg];  // Output 2: Scrap / reject\n} else {\n    return [msg, null];  // Output 1: Continue\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 380,
        "wires": [
            [
                "c42db053064878d5",
                "ae5a25c3d7a52136"
            ],
            [
                "c42db053064878d5"
            ]
        ]
    },
    {
        "id": "16ebbbe831f99f85",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "PRINTER",
        "func": "// STATION 2: PRINTER (Station Number: 1002)\n// ============================================\n\nlet pcb = msg.payload.pcb_tracking;\n\n// Calculate timing\nconst entryTime = pcb.entry_time;\nconst stayTime = (8 + Math.random() * 4) * 1000; // 8–12 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// Generate unique BOOKING_ID\nconst bookingId = \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// Create complete payload\nmsg.payload = {\n    station_record: {\n        BOOKING_ID: bookingId,\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        STATION_NUMBER: \"1002\",\n        BOOK_STATE: \"PASS\",\n        DATE_CREATED: new Date(exitTime).toISOString(),\n        PART_NUMBER: pcb.PART_NUMBER,\n        CYCLE_TIME: cycleTime,\n        TEST_COUNT: 1   // ✅ Always 1 for Printer\n    },\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        PART_NUMBER: pcb.PART_NUMBER,\n        entry_time: exitTime,\n        test_count: pcb.test_count\n    }\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 280,
        "wires": [
            [
                "f9e7392e4fc399a7",
                "6ee2ed6875d5227f"
            ]
        ]
    },
    {
        "id": "0e7b3bb59f90807c",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "PICK AND PLACE 1",
        "func": "// STATION 4: PICK AND PLACE 1 (Station Number: 1004)\n// ============================================\n\nlet pcb = msg.payload.pcb_tracking;\n\n// Calculate timing\nconst entryTime = pcb.entry_time;\nconst stayTime = (20 + Math.random() * 6) * 1000; // 20–26 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// Generate unique BOOKING_ID\nconst bookingId = \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// Build message payload\nmsg.payload = {\n    station_record: {\n        BOOKING_ID: bookingId,\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        STATION_NUMBER: \"1004\",\n        BOOK_STATE: \"PASS\",  // ✅ Always PASS\n        DATE_CREATED: new Date(exitTime).toISOString(),\n        PART_NUMBER: pcb.PART_NUMBER,\n        CYCLE_TIME: cycleTime,\n        TEST_COUNT: 1        // ✅ Always 1 (no retests)\n    },\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        PART_NUMBER: pcb.PART_NUMBER,\n        entry_time: exitTime,\n        test_count: pcb.test_count\n    }\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 480,
        "wires": [
            [
                "254e97e1a89b8f60",
                "d40a32e62d5ac0e5"
            ]
        ]
    },
    {
        "id": "72e0188dd96e8cdd",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "PICK AND PLACE 2",
        "func": "// STATION 5: PICK AND PLACE 2 (Station Number: 1005)\n// ============================================\n\nlet pcb = msg.payload.pcb_tracking;\n\n// Calculate timing\nconst entryTime = pcb.entry_time;\nconst stayTime = (18 + Math.random() * 5) * 1000; // 18–23 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// Generate unique BOOKING_ID\nconst bookingId = \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// Build message payload\nmsg.payload = {\n    station_record: {\n        BOOKING_ID: bookingId,\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        STATION_NUMBER: \"1005\",\n        BOOK_STATE: \"PASS\",  // ✅ Always PASS\n        DATE_CREATED: new Date(exitTime).toISOString(),\n        PART_NUMBER: pcb.PART_NUMBER,\n        CYCLE_TIME: cycleTime,\n        TEST_COUNT: 1        // ✅ Always 1 (no retests)\n    },\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        PART_NUMBER: pcb.PART_NUMBER,\n        entry_time: exitTime,\n        test_count: pcb.test_count\n    }\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 580,
        "wires": [
            [
                "506c00a1e36cbcd6",
                "01aecb9a6867d074"
            ]
        ]
    },
    {
        "id": "3eb4665bf15c6865",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "OVEN",
        "func": "// STATION 6: REFLOW OVEN (Station Number: 1006)\n// ============================================\n\nlet pcb = msg.payload.pcb_tracking;\n\n// Calculate timing\nconst entryTime = pcb.entry_time;\nconst stayTime = (240 + Math.random() * 60) * 1000; // 240–300 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// Generate unique BOOKING_ID\nconst bookingId = \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// Build message payload\nmsg.payload = {\n    station_record: {\n        BOOKING_ID: bookingId,\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        STATION_NUMBER: \"1006\",\n        BOOK_STATE: \"PASS\",   // ✅ Always PASS\n        DATE_CREATED: new Date(exitTime).toISOString(),\n        PART_NUMBER: pcb.PART_NUMBER,\n        CYCLE_TIME: cycleTime,\n        TEST_COUNT: 1         // ✅ Always 1 (no retests)\n    },\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER,\n        PART_NUMBER: pcb.PART_NUMBER,\n        entry_time: exitTime,\n        test_count: pcb.test_count\n    }\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 700,
        "wires": [
            [
                "33d1bd556977997a",
                "82bc8d3b1309850a"
            ]
        ]
    },
    {
        "id": "835f078eb07b2a6a",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": " AOI 1 ",
        "func": "// ============================================\n// STATION 7: AOI 1 (Station Number: 1007)\n// Simplified version — always passes PCB to AOI2\n// ============================================\n\n// ✅ 1. Extract PCB tracking data safely\nlet pcb = msg.payload.pcb_tracking || {};\n\n// ✅ 2. Initialize test count for AOI1\npcb.test_count = pcb.test_count || {};\npcb.test_count.aoi1 = (pcb.test_count.aoi1 || 0) + 1;\n\n// ✅ 3. Calculate timing\nconst entryTime = pcb.entry_time || Date.now();\nconst stayTime = (4 + Math.random() * 2) * 1000; // 4–6 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// ✅ 4. AOI 1 inspection logic (just generate PASS/FAIL)\nlet failRate = 0.08;  // ~18% fail rate\nconst failChance = Math.random();\nlet bookState = failChance < failRate ? \"FAIL\" : \"PASS\";\n\n// ✅ 5. Generate unique BOOKING_ID for THIS test attempt\nconst bookingId =\n  \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// ✅ 6. Create station record for THIS attempt\nconst stationRecord = {\n    BOOKING_ID: bookingId,\n    SERIAL_NUMBER: pcb.SERIAL_NUMBER || \"UNKNOWN\",\n    STATION_NUMBER: \"1007\",\n    BOOK_STATE: bookState,\n    DATE_CREATED: new Date(exitTime).toISOString(),\n    PART_NUMBER: pcb.PART_NUMBER || \"PN-UNKNOWN\",\n    CYCLE_TIME: cycleTime,\n    TEST_COUNT: pcb.test_count.aoi1\n};\n\nnode.warn(`→ Sending AOI record for PCB ${pcb.SERIAL_NUMBER} (${bookState})`);\n\n\n// ✅ 8. Update msg payload for next station (AOI2)\nmsg.payload = {\n    station_record: stationRecord,\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER || \"UNKNOWN\",\n        PART_NUMBER: pcb.PART_NUMBER || \"PN-UNKNOWN\",\n        entry_time: exitTime,\n        test_count: pcb.test_count\n    }\n};\n\n// ✅ 9. Debug logging\nnode.warn(`AOI1: PCB ${pcb.SERIAL_NUMBER} - Result: ${bookState}`);\n\n// ✅ 10. Always forward to AOI2 (only one output used)\nreturn [msg];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 800,
        "wires": [
            [
                "5e13a642d807e9df",
                "a27dd18df7d34054"
            ]
        ]
    },
    {
        "id": "88d20d459a3c17c8",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "AOI 2",
        "func": "// ============================================\n// STATION 8: AOI 2 (Station Number: 1008)\n// ============================================\n\n// ✅ 1. Extract PCB tracking data safely\nlet pcb = msg.payload.pcb_tracking || {};\n\n// ✅ 2. Initialize test count for AOI2\npcb.test_count = pcb.test_count || {};\npcb.test_count.aoi2 = (pcb.test_count.aoi2 || 0) + 1;\n\n// ✅ 3. Calculate timing\nconst entryTime = pcb.entry_time || Date.now();\nconst stayTime = (5 + Math.random() * 2) * 1000; // 5–7 seconds\nconst exitTime = entryTime + stayTime;\nconst cycleTime = (stayTime / 1000).toFixed(2);\n\n// ✅ 4. AOI 2 inspection logic\nlet failRate = pcb.test_count.aoi2 > 1 ? 0.10 : 0.08;  // Slightly lower fail rate after first attempt\nconst failChance = Math.random();\nlet bookState = failChance < failRate ? \"FAIL\" : \"PASS\";\n\n// ✅ 5. Mark as final scrap if failed 3 times\nif (pcb.test_count.aoi2 >= 3 && bookState === \"FAIL\") {\n    pcb.final_scrap = true;\n}\n\n// ✅ 6. Generate unique BOOKING_ID for THIS test attempt\nconst bookingId =\n  \"BK\" + Date.now() + \"-\" + Math.random().toString(36).substr(2, 9).toUpperCase();\n\n// ✅ 7. Create station record for THIS attempt\nconst stationRecord = {\n    BOOKING_ID: bookingId,\n    SERIAL_NUMBER: pcb.SERIAL_NUMBER || \"UNKNOWN\",\n    STATION_NUMBER: \"1008\",\n    BOOK_STATE: bookState,\n    DATE_CREATED: new Date(exitTime).toISOString(),\n    PART_NUMBER: pcb.PART_NUMBER || \"PN-UNKNOWN\",\n    CYCLE_TIME: cycleTime,\n    TEST_COUNT: pcb.test_count.aoi2\n};\n\nnode.warn(`→ Sending AOI record for PCB ${pcb.SERIAL_NUMBER} (${bookState})`);\n\n\n// ✅ 9. Update msg payload for next routing\nmsg.payload = {\n    station_record: stationRecord,\n    pcb_tracking: {\n        SERIAL_NUMBER: pcb.SERIAL_NUMBER || \"UNKNOWN\",\n        PART_NUMBER: pcb.PART_NUMBER || \"PN-UNKNOWN\",\n        entry_time: exitTime,\n        test_count: pcb.test_count,\n        final_scrap: pcb.final_scrap || false\n    }\n};\n\n// ✅ 10. Debug logging\nnode.warn(`AOI2: PCB ${pcb.SERIAL_NUMBER} - Test #${pcb.test_count.aoi2} - Result: ${bookState}`);\n\n// ✅ 11. Routing logic\nif (bookState === \"PASS\") {\n    node.warn(`✅ AOI2 PASS on attempt #${pcb.test_count.aoi2}`);\n    return [msg, null, null]; // → next station (end of line)\n\n} else if (pcb.test_count.aoi2 < 3) {\n    node.warn(`⚠️ AOI2 FAIL - Send back to AOI1 for recheck #${pcb.test_count.aoi2}/3`);\n    return [null, msg, null]; // → AOI1 input\n\n} else {\n    node.warn(`❌ AOI2 FINAL SCRAP after ${pcb.test_count.aoi2} attempts`);\n    return [null, null, msg]; // → scrap bin\n}\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 920,
        "wires": [
            [
                "0ee1edf6d6056eca",
                "c3c7c46f9d157431"
            ],
            [
                "835f078eb07b2a6a",
                "0ee1edf6d6056eca"
            ],
            [
                "0ee1edf6d6056eca"
            ]
        ]
    },
    {
        "id": "53ff54009992a544",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA LOADER",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\",  field: \"cycle_time\" },\n            { type: \"int32\",  field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 140,
        "wires": [
            [
                "61ce08d2e434a7fe",
                "3ade3a6cb2aa6f43"
            ]
        ]
    },
    {
        "id": "f9e7392e4fc399a7",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA PRINTER",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\", field: \"cycle_time\" },\n            { type: \"int32\", field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 240,
        "wires": [
            [
                "63f9557b86f4719f",
                "0b44bbb8f9954358"
            ]
        ]
    },
    {
        "id": "c42db053064878d5",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA SPI",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\",  field: \"cycle_time\" },\n            { type: \"int32\",  field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 340,
        "wires": [
            [
                "3e99cbd24d8990d5",
                "41a8f1281b5bb19e"
            ]
        ]
    },
    {
        "id": "254e97e1a89b8f60",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA PP1",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\",  field: \"cycle_time\" },\n            { type: \"int32\",  field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 440,
        "wires": [
            [
                "91a7154da1fb5502",
                "1648832d26da60aa"
            ]
        ]
    },
    {
        "id": "506c00a1e36cbcd6",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA PP2",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\",  field: \"cycle_time\" },\n            { type: \"int32\",  field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 560,
        "wires": [
            [
                "952169a9ad61ee53",
                "74f755015c2e3adc"
            ]
        ]
    },
    {
        "id": "33d1bd556977997a",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA OVEN",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\", field: \"cycle_time\" },\n            { type: \"int32\", field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 660,
        "wires": [
            [
                "6762c3e49d03197e",
                "4a4a90992a26879f"
            ]
        ]
    },
    {
        "id": "a27dd18df7d34054",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA AOI1",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\",  field: \"cycle_time\" },\n            { type: \"int32\",  field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 760,
        "wires": [
            [
                "26815f58a98cc130",
                "04bc037c9a6f391d"
            ]
        ]
    },
    {
        "id": "0ee1edf6d6056eca",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "EXTRACT STATION DATA AOI2",
        "func": "// EXTRACT STATION DATA - LOADER\n// Converts Loader station_record into Kafka Connect structured JSON\n// ================================================================\n\nconst record = msg.payload.station_record;\n\nconst structuredMsg = {\n    schema: {\n        type: \"struct\",\n        fields: [\n            { type: \"string\", field: \"booking_id\" },\n            { type: \"string\", field: \"serial_number\" },\n            { type: \"string\", field: \"station_number\" },\n            { type: \"string\", field: \"book_state\" },\n            {\n                type: \"int64\",\n                field: \"date_created\",\n                name: \"org.apache.kafka.connect.data.Timestamp\"\n            },\n            { type: \"string\", field: \"part_number\" },\n            { type: \"float\",  field: \"cycle_time\" },\n            { type: \"int32\",  field: \"test_count\" }     // ✅ NEW FIELD for retest tracking\n        ],\n        optional: false,\n        name: \"station_records\"\n    },\n    payload: {\n        booking_id: record.BOOKING_ID,\n        serial_number: record.SERIAL_NUMBER,\n        station_number: record.STATION_NUMBER,\n        book_state: record.BOOK_STATE,\n        // Convert ISO string → timestamp (milliseconds)\n        date_created: new Date(record.DATE_CREATED).getTime(),\n        part_number: record.PART_NUMBER,\n        cycle_time: parseFloat(record.CYCLE_TIME),\n        test_count: record.TEST_COUNT ? parseInt(record.TEST_COUNT) : 1  // ✅ default 1\n    }\n};\n\nmsg.payload = JSON.stringify(structuredMsg);\nmsg.topic = \"smt-station-events\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 900,
        "wires": [
            [
                "b5e2d65cb12e4a50",
                "9d3669bb6267fd6c"
            ]
        ]
    },
    {
        "id": "0c26ab5f5ce5ca69",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/loader push",
        "topic": "smt1/loader/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f2e4c66763f10fa9",
        "x": 910,
        "y": 180,
        "wires": []
    },
    {
        "id": "e780b1f7852b1fc3",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 180,
        "wires": [
            [
                "9593f81ea95e5b22"
            ]
        ]
    },
    {
        "id": "e3cbf0394c170d10",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/loader pull",
        "topic": "smt1/loader/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "f2e4c66763f10fa9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 340,
        "y": 280,
        "wires": [
            [
                "16ebbbe831f99f85"
            ]
        ]
    },
    {
        "id": "6ee2ed6875d5227f",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/printer push",
        "topic": "smt1/printer/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f4640e98347ece66",
        "x": 910,
        "y": 280,
        "wires": []
    },
    {
        "id": "98d707d9b2af4589",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/printer pull",
        "topic": "smt1/printer/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "f4640e98347ece66",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 340,
        "y": 380,
        "wires": [
            [
                "c72a4935dbd7b1a0"
            ]
        ]
    },
    {
        "id": "ae5a25c3d7a52136",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/spi push",
        "topic": "smt1/spi/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "43a8f184b06a8296",
        "x": 900,
        "y": 380,
        "wires": []
    },
    {
        "id": "e9c246d2732bd87d",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/spi pull",
        "topic": "smt1/spi/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "43a8f184b06a8296",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 480,
        "wires": [
            [
                "0e7b3bb59f90807c"
            ]
        ]
    },
    {
        "id": "d40a32e62d5ac0e5",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/pp1 push",
        "topic": "smt1/pp1/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "be3e1f50d2e272ac",
        "x": 900,
        "y": 480,
        "wires": []
    },
    {
        "id": "1906945ad73cf065",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/pp1 pull",
        "topic": "smt1/pp1/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "be3e1f50d2e272ac",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 580,
        "wires": [
            [
                "72e0188dd96e8cdd"
            ]
        ]
    },
    {
        "id": "61ce08d2e434a7fe",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 80,
        "wires": []
    },
    {
        "id": "63f9557b86f4719f",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 200,
        "wires": []
    },
    {
        "id": "01aecb9a6867d074",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/pp2 push",
        "topic": "smt1/pp2/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "ee0822dd8f04d988",
        "x": 900,
        "y": 600,
        "wires": []
    },
    {
        "id": "8dd9de32dc65b3e7",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/pp2 pull",
        "topic": "smt1/pp2/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "ee0822dd8f04d988",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 700,
        "wires": [
            [
                "3eb4665bf15c6865"
            ]
        ]
    },
    {
        "id": "82bc8d3b1309850a",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/oven push",
        "topic": "smt1/oven/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "4c30baa4e5ca2436",
        "x": 900,
        "y": 700,
        "wires": []
    },
    {
        "id": "d3666f7a86bc875f",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/oven pull",
        "topic": "smt1/oven/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "4c30baa4e5ca2436",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 800,
        "wires": [
            [
                "835f078eb07b2a6a"
            ]
        ]
    },
    {
        "id": "5e13a642d807e9df",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/aoi1 push",
        "topic": "smt1/aoi1/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d4e5ec3427485135",
        "x": 900,
        "y": 800,
        "wires": []
    },
    {
        "id": "2547ed9edf24d20b",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/aoi1 pull",
        "topic": "smt1/aoi1/events",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "d4e5ec3427485135",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 920,
        "wires": [
            [
                "88d20d459a3c17c8"
            ]
        ]
    },
    {
        "id": "c3c7c46f9d157431",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "smt1/aoi2 push",
        "topic": "smt1/aoi2/events",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "27fc9fe771719233",
        "x": 900,
        "y": 940,
        "wires": []
    },
    {
        "id": "3e99cbd24d8990d5",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 300,
        "wires": []
    },
    {
        "id": "91a7154da1fb5502",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 400,
        "wires": []
    },
    {
        "id": "952169a9ad61ee53",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 5",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 520,
        "wires": []
    },
    {
        "id": "6762c3e49d03197e",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 620,
        "wires": []
    },
    {
        "id": "26815f58a98cc130",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 7",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 720,
        "wires": []
    },
    {
        "id": "b5e2d65cb12e4a50",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 8",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 880,
        "wires": []
    },
    {
        "id": "3ade3a6cb2aa6f43",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka loader",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": "0",
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1300,
        "y": 120,
        "wires": []
    },
    {
        "id": "0b44bbb8f9954358",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka printer",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": "0",
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1300,
        "y": 240,
        "wires": []
    },
    {
        "id": "41a8f1281b5bb19e",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka spi",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": 0,
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1290,
        "y": 340,
        "wires": []
    },
    {
        "id": "1648832d26da60aa",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka pp1",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": 0,
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1290,
        "y": 440,
        "wires": []
    },
    {
        "id": "74f755015c2e3adc",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka  pp2",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": 0,
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1290,
        "y": 560,
        "wires": []
    },
    {
        "id": "4a4a90992a26879f",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka oven",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": 0,
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1290,
        "y": 660,
        "wires": []
    },
    {
        "id": "04bc037c9a6f391d",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka aoi1",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": 0,
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1290,
        "y": 760,
        "wires": []
    },
    {
        "id": "9d3669bb6267fd6c",
        "type": "Kafka Producer",
        "z": "f6f2187d.f17ca8",
        "name": "send to kafka aoi2",
        "broker": "bad1a1ab4cc09f88",
        "topic": "smt-station-events",
        "topicSlash2dot": false,
        "requireAcks": 1,
        "ackTimeoutMs": 100,
        "partitionerType": 0,
        "key": "",
        "partition": 0,
        "attributes": 0,
        "connectionType": "Producer",
        "convertFromJson": false,
        "x": 1290,
        "y": 920,
        "wires": []
    },
    {
        "id": "9593f81ea95e5b22",
        "type": "postgresql",
        "z": "f6f2187d.f17ca8",
        "name": "",
        "query": "SELECT MAX(date_created AT TIME ZONE 'UTC' + INTERVAL '2 hours') AS last_timestamp\nFROM public.station_records;\n",
        "postgreSQLConfig": "5afc3e3855fc7545",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 310,
        "y": 180,
        "wires": [
            [
                "449e34174cb2c12c",
                "17b326f813964c67"
            ]
        ]
    },
    {
        "id": "449e34174cb2c12c",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "debug 9",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 80,
        "wires": []
    }
]